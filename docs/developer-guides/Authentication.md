# Authentication and Authorization

This document details the authentication and authorization mechanisms used in the "Adopte1Etudiant" application.

---

## 1. Authentication Strategy

The application uses a **token-based authentication** system with **JSON Web Tokens (JWT)**. This approach ensures that the backend remains stateless, which is crucial for scalability and simplicity.

Users can authenticate in two ways:
1.  **Email & Password**: The classic credential-based login.
2.  **OAuth 2.0**: Via third-party providers, starting with Google.

### Authentication Flow (JWT)

1.  **Login**: A user submits their credentials (email/password) or goes through the OAuth flow.
2.  **Verification**: The backend API verifies the credentials against the database or validates the OAuth token with the provider.
3.  **Token Generation**: Upon successful verification, the server generates a signed JWT. This token contains a payload with essential, non-sensitive user information, such as:
    *   `userId`: The unique identifier for the user.
    *   `role`: The user's role (`STUDENT` or `COMPANY`).
    *   `iat` (Issued At) and `exp` (Expiration Time) timestamps.
4.  **Token Transmission**: The JWT is sent back to the client.
5.  **Token Storage**: The frontend uses **HTTP-only cookies** (with `secure` enabled in production) to mitigate XSS risks. In non-browser clients, use the `Authorization: Bearer <token>` header.
6.  **Authenticated Requests**: For every subsequent request to a protected API endpoint, include the cookie (browser) or the `Authorization` header (non-browser).
    ```
     Authorization: Bearer <your_jwt_token>
    ```
7.  **Server-side Verification**: The `authMiddleware` on the backend intercepts each request, verifies the JWT's signature and expiration, and if valid, extracts the user information from the payload. This information is then attached to the request object (e.g., `request.user`) for use in downstream controllers.

---

## 2. Authentication Scenarios

### Email & Password

*   **Registration (`/api/auth/register`)**:
    1.  A user provides their email, password, role (`STUDENT` or `COMPANY`), and other profile details.
    2.  The backend hashes the password using a strong algorithm (e.g., bcrypt).
    3.  A new `User` record is created in the database.
    4.  The user is then expected to log in.
*   **Login (`/api/auth/login`)**:
    1.  A user submits their email and password.
    2.  The backend finds the user by email and compares the submitted password with the stored hash.
    3.  On success, a new JWT is generated and returned.

### OAuth 2.0 with Google

*   **Login (`/api/auth/google`, `/api/auth/google/callback`)**:
    1.  The user clicks the "Sign in with Google" button on the frontend, which redirects them to the `/api/auth/google` endpoint.
    2.  The backend redirects the user to Google's consent screen.
    3.  After the user grants permission, Google redirects them back to the `/api/auth/google/callback` endpoint with an authorization code.
    4.  The backend exchanges this code for an access token and retrieves the user's Google profile information.
    5.  The system then performs an "upsert":
        *   If a user with this Google ID already exists, they are logged in.
        *   If a user with this email exists but doesn't have a Google account linked, the accounts are linked.
        *   If no such user exists, a new `User` and `OAuthAccount` are created.
    6.  A JWT is generated and returned to the frontend, typically via a redirect with the token in the URL query parameters.

### Account Linking

A user who originally signed up with an email and password can link their Google account from their profile page. This allows them to log in using either method. They also have the option to disable password-based login for enhanced security, making Google the sole method of authentication for their account.

---

## 3. Two-Factor Authentication (2FA)

To enhance account security, the application supports **Time-based One-Time Password (TOTP)** for two-factor authentication. Once enabled, users will need to provide a rotating 6-digit code from an authenticator app (e.g., Google Authenticator, Authy) in addition to their password or after an OAuth login.

### 2FA Flow

1.  **Setup**: The user initiates 2FA setup from their profile, which generates a unique secret key. This key is typically displayed as a QR code for easy scanning into an authenticator app.
2.  **Verification (Initial)**: The user verifies the setup by entering a code generated by their authenticator app. Upon successful verification, 2FA is activated for their account.
3.  **Login with 2FA**: After successful primary authentication (email/password or OAuth), the system prompts for a 2FA code. The user enters the code from their authenticator app.
4.  **Recovery Codes**: During 2FA setup, recovery codes are provided. These are one-time use codes that allow access to the account if the authenticator device is lost or inaccessible.
5.  **Disable**: Users can disable 2FA from their profile by re-entering their password.

### Key Endpoints for 2FA

*   `POST /api/2fa/generate`: Generates a new 2FA secret and a QR code. Requires authentication.
*   `POST /api/2fa/verify`: Verifies a provided 2FA token and enables 2FA for the user's account. Requires the generated secret and a valid token.
*   `POST /api/2fa/disable`: Disables 2FA for the authenticated user. Requires password verification.

### Example Usage

#### Generate 2FA Secret

```bash
curl -X POST http://localhost:8080/api/2fa/generate \
  -H "Content-Type: application/json" \
  -b cookies.txt
# Response will contain `secret` and `otpAuthUrl` for QR code generation.
```

#### Verify and Enable 2FA

```bash
curl -X POST http://localhost:8080/api/2fa/verify \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "token": "123456" # Code from authenticator app
  }'
```

#### Login with 2FA

After a successful password login, if 2FA is enabled, the API will return a specific response indicating 2FA is required. The client should then make a subsequent call:

```bash
curl -X POST http://localhost:8080/api/auth/login/verify-2fa \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "token": "654321" # Code from authenticator app
  }'
```

---

## 4. Authorization (RBAC)

### Rate Limiting

The API enforces rate limits to mitigate brute force and abuse:
- Global limit: 100 req/min
- Login: 10 req/min per IP
- 2FA verification: 6 req/10min per IP
- Registration: 10 req/min per IP

See `apps/api/src/index.ts` and `apps/api/src/routes/auth.ts`.

Authorization is managed using **Role-Based Access Control (RBAC)**. The system defines two primary roles:

*   `STUDENT`: Can search for offers, apply to them, and manage their applications.
*   `COMPANY`: Can post job offers, view applicants, and search for students.

### Implementation

*   **Role in JWT**: The user's role is embedded within the JWT payload. This avoids the need for a database lookup on every request to determine the user's role.
*   **`roleMiddleware`**: A dedicated middleware is used to protect routes based on roles. It checks the `role` from the decoded JWT against a list of allowed roles for that specific endpoint.

#### Example Usage:

To restrict an endpoint to `COMPANY` users only, the `roleMiddleware` is applied to the route definition:

```typescript
// Example from a route file in `apps/api/src/routes`

import { roleMiddleware }s from '../middleware/roleMiddleware';

// This route is only accessible to users with the 'COMPANY' role.
fastify.post(
  '/offers',
  { preHandler: [authMiddleware, roleMiddleware(['COMPANY'])] },
  offerController.createOffer
);
```

If a user without the required role attempts to access the endpoint, the middleware will reject the request with a `403 Forbidden` status code.
